#!/usr/bin/python3

# Copyright Â© 2014 mutantmonkey <mutantmonkey@mutantmonkey.in>
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# the COPYING file for more details.

import asyncore
import asynchat
import binascii
import shlex
import socket


class TorControlProxyHandler(asynchat.async_chat):
    authenticated = False

    def __init__(self, control_socket, auth_cookie_path, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.control_socket = control_socket
        self.auth_cookie_path = auth_cookie_path
        self.ibuffer = []
        self.set_terminator(b"\n")

    def collect_incoming_data(self, data):
        """Buffer the data."""
        self.ibuffer.append(data)

    def found_terminator(self):
        data = b"".join(self.ibuffer).decode('ascii')
        self.ibuffer = []
        command = shlex.split(data)

        if len(command) < 1:
            return
        else:
            print(command)

        if command[0].lower() == 'authenticate':
            # we do the authentication later, as it's not needed yet
            self.authenticated = True
            self.send_reply(250, 'OK')
        elif command[0].lower() == 'quit':
            self.send_reply(250, 'closing connection')
            self.close()
        elif self.authenticated:
            if command[0].lower() == 'getinfo':
                info_key = self.get_next_argument(command)
                if info_key == 'net/listeners/socks':
                    # send a fake response to make TBB happy
                    self.push('250-net/listeners/socks="{}:9050"\r\n'.format(
                        self.socket.getsockname()[0]).encode('utf-8'))
                    self.send_reply(250, 'OK')
                elif info_key == 'status/bootstrap-phase':
                    self.pass_message('GETINFO status/bootstrap-phase')
                else:
                    self.send_reply(
                        510,
                        'Unrecognized key "{}"'.format(info_key))
            elif command[0].lower() == 'signal':
                signal_code = self.get_next_argument(command)
                if signal_code.lower() == 'newnym':
                    self.pass_message('SIGNAL NEWNYM')
                else:
                    self.send_reply(
                        552,
                        'Unrecognized signal code "{}"'.format(signal_code))
            else:
                self.send_reply(
                    510,
                    'Unrecognized command "{}"'.format(command[0]))
        else:
            self.send_reply(514, 'Authentication required.')

    def close(self):
        super().close()

    @staticmethod
    def get_next_argument(command):
        if len(command) > 1:
            return command[1]
        else:
            return ""

    def pass_message(self, msg):
        # read auth cookie
        with open(self.auth_cookie_path, 'rb') as f:
            auth_cookie = f.read(32)
            hex_cookie = str(binascii.hexlify(auth_cookie), 'ascii')

        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(10.0)
        sock.connect(self.control_socket)

        readh = sock.makefile('r')
        writeh = sock.makefile('w')

        # authenticate
        writeh.write("AUTHENTICATE {}\n".format(hex_cookie))
        writeh.flush()
        result = readh.readline()
        if not result.strip() == "250 OK":
            self.push(result)
            sock.close()
            return

        writeh.write("{}\n".format(msg))
        writeh.flush()

        answer = sock.recv(16384)
        self.push(answer)
        sock.close()

    def send_reply(self, code, msg):
        out = "{0} {1}\r\n".format(code, msg)
        self.push(out.encode('utf-8'))


class TorControlProxyServer(asyncore.dispatcher):
    def __init__(self, host, port, control_socket="/run/tor/control",
                 auth_cookie_path="/run/tor/control.authcookie"):
        super().__init__()

        self.control_socket = control_socket
        self.auth_cookie_path = auth_cookie_path

        self.create_socket()
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(5)

    def handle_accepted(self, sock, addr):
        print("Got connection from {}".format(addr))
        handler = TorControlProxyHandler(self.control_socket,
                                         self.auth_cookie_path, sock)


if __name__ == '__main__':
    server = TorControlProxyServer('0.0.0.0', 9052)
    asyncore.loop()
